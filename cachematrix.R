## Matrix inversion is usually a costly computation and
##their may be some benefit to caching the inverse of a matrix rather than compute it repeatedly 
##Therefore, the first function makeCacheMatrix creates a matrix object with a cache built into it
##The second function cacheSolve checks if the matrix object generated by makeCacheMatrix has its
##inverse computed;if yes, returns the value from the cache; otherwise, compute it and return the result.

## This function creates a special "matrix" object that can cache it's inverse. 
##That cache is like "m" in assignment example
##I use another name called inverseholder
##To check if it works, use the invertible matrix:matrix(c(1,1,1,3,4,3,3,3,4),3,3)

makeCacheMatrix <- function(x = matrix()) {
    inverseholder<-NULL
    set<-function(y){   ##This is not required in the assignment;however, I keep it as imitation
        x<<-y
        inverseholder<<-NULL 
    }
    get<-function()x
    setinverse<-function(inverse) inverseholder<<-inverse
    getinverse<-function()inverseholder
    list(set=set,get=get,setinverse=setinverse,getinverse=getinverse)
    
}


## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above. 
##If the inverse has already been calculated (and the matrix has not changed), 
##then the cacheSolve should retrieve the inverse from the cache

cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
    inverse<-x$getinverse()
    if(!is.null(inverse)){
        message("getting cached data")
        return(inverse)
    }
    data<-x$get()
    inverse<-solve(data,...)
    x$setinverse(inverse)
    inverse
}

##The output is below
##  >matrix1<-makeCacheMatrix(matrix(c(1,1,1,3,4,3,3,3,4),3,3))
##  > cacheSolve(matrix1)
##        [,1] [,2] [,3]
##  [1,]    7   -3   -3
##  [2,]   -1    1    0
##  [3,]   -1    0    1
##  > cacheSolve(matrix1)
##  getting cached data
##      [,1] [,2] [,3]
##  [1,]    7   -3   -3
##  [2,]   -1    1    0
##  [3,]   -1    0    1
 